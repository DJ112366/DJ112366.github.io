<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2021/02/23/%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0/</url>
    <content><![CDATA[<p>​    2021年2月23日有了自己的blog，继续加油呀！！！<img src="file:///C:\Users\82036\AppData\Local\Temp\SGPicFaceTpBq\18952\02D39473.gif" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>date: 2021-02-24 11:54:29<br>permalink:<br>categories:<br>tags: [数据结构, 算法]<br>description: 数据结构学习，参考教</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>给与足够的眼球，所有的Bugs都很容易发现（例如，大量的beta测试，结对开发，所有的问题都能很快的发现和修复</p>
<p> — Eric S. Raymond, 程序员，开源软件的倡导者, 出自《The Cathedral and the Bazaar》</p>
</blockquote>
<span id="more"></span>

<h2 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h2><h3 id="1-0数据结构是用来干嘛的？"><a href="#1-0数据结构是用来干嘛的？" class="headerlink" title="1.0数据结构是用来干嘛的？"></a>1.0数据结构是用来干嘛的？</h3><p>1.将现实世界进行信息化展示。</p>
<p>2.利用计算机高效的处理信息从而创造价值。</p>
<h3 id="2-0-数据结构相关的基本概念"><a href="#2-0-数据结构相关的基本概念" class="headerlink" title="2.0 数据结构相关的基本概念"></a>2.0 数据结构相关的基本概念</h3><p>1.什么是数据？</p>
<p>数据：数据是信息的<strong>载体</strong>，是描述客观事物属性的<strong>数</strong>，<strong>字符</strong>。能够输入到<strong>计算机</strong>中并被计算机程序<strong>识别</strong>和<strong>处理</strong>的符号的集合，计算机程序加工的原料。</p>
<blockquote>
<p>例：站在计算机的角度来看，数据就是 0 / 1 。</p>
</blockquote>
<p>2.什么是数据元素，数据项？</p>
<p>数据元素：数据元素是数据的<strong>基本单位</strong>，通常作为一个<strong>整体</strong>进行考虑和处理。</p>
<p>数据元素是由数据项组成的。</p>
<blockquote>
<p>例：账号是数据元素，那么账号内部包含的昵称，性别，生日则是数据项。</p>
</blockquote>
<p>3.数据项：数据元素由数据像组成，数据项是不可分割的最小单位。</p>
<blockquote>
<p>例：以人为例，人是由身高，体重，性别属性组成。在这个例子中人是数据元素，而身高，体重，性别则是数据项。</p>
</blockquote>
<p>4.数据结构，数据对象</p>
<p>数据结构是<strong>数据对象</strong>在计算机中的组织方式。数据结构强调的是数据元素之间的<strong>关系</strong>，侧重点是关系！</p>
<p>数据对象指相同性质的数据元素组成的集合，属于数据的<strong>子集</strong>。侧重点是<strong>相同性质</strong>。</p>
<blockquote>
<p>例：以排队为例，人员之间的相对顺序是数据结构所要关注的，而排队的都是人则是数据对象要关注的。</p>
</blockquote>
<h2 id="3-0-数据结构的三要素"><a href="#3-0-数据结构的三要素" class="headerlink" title="3.0 数据结构的三要素"></a>3.0 数据结构的三要素</h2><p>逻辑结构，物理结构（存储结构），数据的运算。</p>
<p>这三者可以唯一确定一个数据结构，缺一不可。</p>
<h3 id="3-1-逻辑结构"><a href="#3-1-逻辑结构" class="headerlink" title="3.1 逻辑结构"></a>3.1 逻辑结构</h3><p>数据的逻辑结构分为<strong>集合</strong>，<strong>线性结构</strong>，<strong>树形结构</strong>，<strong>图状结构（网状结构）</strong>。</p>
<p>集合:各个元素同属一个集合，不存在其他关系。</p>
<p>线性结构：数据元素之间存在一对一的关系。除了第一个元素和最后一个元素之外，每一个元素都有唯一的前驱和唯一的后继。第一个元素有唯一后继，最后一个元素则有唯一前驱。</p>
<p>树：一对多的关系。</p>
<p>图：多对多的关系。</p>
<h3 id="3-2-物理结构（存储结构）"><a href="#3-2-物理结构（存储结构）" class="headerlink" title="3.2 物理结构（存储结构）"></a>3.2 物理结构（存储结构）</h3><p>物理结构分为<strong>顺序存储，链式存储，索引存储，散列存储</strong>。</p>
<ul>
<li>顺序存储指逻辑上相邻的元素，其物理存储位置<strong>也相邻</strong>。</li>
<li>链式存储指逻辑上相邻的元素，其物理存储位置<strong>不相邻</strong>。</li>
<li>索引存储指简历一张索引表，该表一般由关键字和地址组成，通过查询该表关键字找到地址来区分。</li>
<li>散列存储，根据关键字来计算存储地址。例如 Hash。</li>
</ul>
<p>物理存储也可以按照顺序存储和非顺序存储来划分。其中链式存储，索引存储，散列存储统称为非顺序存储。</p>
<p>顺序存储的物理地址是连续的，而非顺序存储的物理地址是不连续的。</p>
<p>在空间分配方面，相较于非顺序存储，顺序存储分配空间较为麻烦。</p>
<p>顺序存储的索引方便，非顺序存储索引麻烦。（因为无序，需要挨个遍历）</p>
<h3 id="3-3-数据运算"><a href="#3-3-数据运算" class="headerlink" title="3.3 数据运算"></a>3.3 数据运算</h3><p><strong>运算的定义</strong>是针对逻辑结构的，实现运算的功能。</p>
<p><strong>运算的实现</strong>是针对存储结构的，实现运算的具体步骤</p>
<h2 id="4-0-数据类型，抽象数据类型"><a href="#4-0-数据类型，抽象数据类型" class="headerlink" title="4.0 数据类型，抽象数据类型"></a>4.0 数据类型，抽象数据类型</h2><p>数据类型是值的集合和定义在此集合上的一组操作的总称。</p>
<p>原子类型，例如 int bool 等。</p>
<p>结构类型，例如结构体。</p>
<p>抽象数据类型。ADT 抽象数据组织与之相关的操作。</p>
<img src="https://cdn.jsdelivr.net/gh/weijiew/pic@master/images/image.25y1jshqwlwg.png"  style="float: left;" />

<h2 id="5-0-总结"><a href="#5-0-总结" class="headerlink" title="5.0 总结"></a>5.0 总结</h2><ol>
<li>在面对一个问题之时，首先要确定的就是 ADT，也就是定义了数据的逻辑结构。</li>
<li>定义数据运算，针对逻辑结构考虑需要怎么计算实现。</li>
<li>根据计算方式确定合适的存储结构。存储结构不同运算实现的具体方式也不同，最后实现数据结构。</li>
</ol>
<h2 id="6-0-算法"><a href="#6-0-算法" class="headerlink" title="6.0 算法"></a>6.0 算法</h2><p>算法是解决问题的计算步骤。</p>
<p>程序 = 数据结构 + 算法</p>
<p>算法具备以下特点：有穷性，确定性，可行性，输入和输出。</p>
<ul>
<li>有穷性：优先步骤内完成，程序可以是无穷的。</li>
<li>确定性：一个输入对应一个输出，不存在一个输入对应多个输出。</li>
<li>可行性：该算法的操作可以通过基本运算的有限次内实现。</li>
<li>输入：<strong>零个</strong>或<strong>多个</strong>输入，注意可以不需要输入。</li>
<li>输出：<strong>一个</strong>或<strong>多个</strong>输出，注意需要输出。</li>
</ul>
<p>好算法的特质：正确性，易读性，健壮性，高效性，低存储性。</p>
<p>健壮性指输入非法数据时算法可以进行处理。</p>
<h2 id="7-0-效率的度量"><a href="#7-0-效率的度量" class="headerlink" title="7.0 效率的度量"></a>7.0 效率的度量</h2><p>事后统计算法运行时间的问题：算法的时间开销和机器性能有关，编程语言有关，机器置零质量有关。有些算法是不能进行事后统计的，例如导弹控制。</p>
<p>时间复杂度：算法基本运算的执行次数作为度量标准。</p>
<p>时间复杂度本质上是根据算法来判断数据规模所需的时间。</p>
<p>时间开销 T 和问题规模 N 之间的关系。</p>
<p>空间复杂度：算法占用空间的大小。一般将算法的辅助空间作为衡量空间复杂度的标准。</p>
<p>算法的存储空间 = 输入/输出数据所占空间 + 算法本身所长空间 + 额外的辅助空间.</p>
<p>问题规模足够大之时，只需要考虑阶数最高的部分。</p>
<p>$$T=n^2+3*n+1000 $$等价于$$n^2$$ </p>
<p>采用 表示法，，表示同阶，也就是当 n 趋近于正无穷之时，二者之比为常数。</p>
<p>加法规则：多项相加，只保留最高阶的项，且系数为 1 .</p>
<p>乘法规则：多项相乘，都保留。</p>
<p>常见的函数增量曲线。</p>
<img src="https://gitee.com/weijiew/pic/raw/master/img/20200510153247.png" alt="image-20200916114846002"  style="float: left;" />

<p>速度递增口诀：常对幂指阶。</p>
<p>只需要关注循环部分，顺序执行的代码影响的是常数部分。</p>
<p>一般考虑最坏时间复杂度，平均时间复杂度。而最好时间复杂度一般不考虑。</p>
<p>空间复杂度：</p>
<p>随着问题规模的变换，算法运行所需的内存空间都是固定的常量，那么称该算法为原地工作。</p>
<p>递归程序的空间复杂度等于递归调用的深度</p>
<h1 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h1><p>线性表的定义和基本操作。</p>
<h2 id="1-线性表的定义"><a href="#1-线性表的定义" class="headerlink" title="1. 线性表的定义"></a>1. 线性表的定义</h2><p><strong>同类型元素</strong>组成的<strong>有限序列</strong>，除首元素和尾元素外每个元素都有唯一前驱和唯一后继，首元素只有唯一后继，尾元素只有唯一前驱。</p>
<p>注意位序是从 1 开始，而数组下标是从 0 开始！</p>
<p>线性表的存储方式：顺序存储（顺序表）和链式存储（链式表）。</p>
<p>顺序存储采用数组实现，而数组可以采用静态数组和动态数组分别实现。</p>
<h2 id="2-顺序表"><a href="#2-顺序表" class="headerlink" title="2. 顺序表"></a>2. 顺序表</h2><p>顺序表中元素的存储位置是连续的。所以定位迅速，但是插入和删除需要移动后续的元素导致比较费时间。</p>
<p>根据分配内存的方式，顺序表可以分为静态分配和动态分配两种类型。</p>
<p>静态分配：提前为定长的数组申请一块空间，数组的长度固定，但是如果后续的操作导致数组的空间不够用了，那就采用动态分配的方式。</p>
<p>顺序表操作简单，存储密度高，可以随机存取。但是需要预先分配空间，空间分配多了可能会导致浪费反之会导致溢出。如果需要经常插入或删除的话顺序表效率低，可以考虑链式存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">// typedef 相当于取一个小名，使得 ElemType 等价于 int </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100 <span class="comment">// 预先分配的空间</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    ElemType data[Maxsize]; <span class="comment">// ElemType 是自定义的</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 顺序表的长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>动态分配：为数组申请空间，length 记录实际存储的元素个数，一旦空间不够用就再申请一块更大的空间，将原来数组中的数据放进去，然后再放后续存进来的数据而非在原来的地址上扩容。就像家里人多，房子太小，所以买一个新房子，然后搬家，而不是在原来的房子上进行扩建。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemTyep *elem; <span class="comment">// * 表示取地址中存放的内容</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<h2 id="3-顺序表的基本操作"><a href="#3-顺序表的基本操作" class="headerlink" title="3. 顺序表的基本操作"></a>3. 顺序表的基本操作</h2><h3 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h3><p>思路：首先需要为数组申请空间，一旦申请失败就返回 false 反之 true ，申请成功后还需要将当前长度设置为 0 因为此时列表中还没有元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.elem = <span class="keyword">new</span> <span class="keyword">int</span>[Maxsize];</span><br><span class="line">    <span class="keyword">if</span> (L.elem == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，初始化的时候实际上是需要初始化的（例如全部置 0 ）因为可能存在脏数据，也就是之前申请空间之时此处遗留下来的数据。其实问题就在于操作系统在删除数据之时不会讲数据全部置零，而是标记一下这块内存没用了，但是实际上是存有数据的，等待新数据存入之后将之覆盖。</p>
<h3 id="3-2-创建"><a href="#3-2-创建" class="headerlink" title="3.2 创建"></a>3.2 创建</h3><p>思路：目的是为了将数据存入列表中，那么什么时候是输入结束？如果提前知道输入数据的个数的话就直接一个 for 循环即可，反之则需要设置一个特殊值，这里设置的是 -1 每次输入数据之前需要输入一个值来表明需要向数组中填入数据，一旦输入 -1 表明数据输入完了，不需要再填入即循环结束，例如 1 2 3 4 5 6 -1 输入填入数组中的值是 2 4 6 ，而1 3 5 -1 都是用来判断是否继续输入的，-1 则表示后面没有数据了，不输入。 在输入的同时还需要防止数组不能够越界，也就是每输入进去一个数据之前要判断数组空间是否还有剩余，如果空间以满就输出 false 反之 true 最终将数据输入其中，即可构建顺序表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.length == Maxsize) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        L.elem[i++] = x;</span><br><span class="line">        L.length++;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-取值"><a href="#3-3-取值" class="headerlink" title="3.3 取值"></a>3.3 取值</h3><p>思路：首先需要判断当前数需要查找的值是否越界，越界的话就返回 false 反之取出数据即可，注意下标是从零开始。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElement</span><span class="params">(SqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a = L.elem[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-查找"><a href="#3-4-查找" class="headerlink" title="3.4 查找"></a>3.4 查找</h3><p>思路：判断列表中是否存在某个元素，如果存在就输出位置，反之输出 -1 ，遍历即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-插入"><a href="#3-5-插入" class="headerlink" title="3.5 插入"></a>3.5 插入</h3><p>思路：首先剩余空间是否能够容纳插入的元素，其次则是插入位置，插入之后后续位置上元素都要后移。那么函数签名则分别是列表，插入位置，插入元素。其次需要先移动元素，然后在放需要插入的元素，反之被插位置上的元素会被覆盖。注意需要先从尾部开始移动，否在元素会被覆盖。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertElem</span><span class="params">(SqList L, <span class="keyword">int</span> i,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length<span class="number">-1</span>; j &gt;= i<span class="number">-1</span>; j--) &#123;</span><br><span class="line">        L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i<span class="number">-1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-删除"><a href="#3-6-删除" class="headerlink" title="3.6 删除"></a>3.6 删除</h3><p>思路：首先判断范围，然后保存一下删除位置的变量，这个随意如果后续有用的话就保存反之不用。然后将原来位置的元素直接覆盖就行了，长度减一</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteElem</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-单链表"><a href="#4-单链表" class="headerlink" title="4. 单链表"></a>4. 单链表</h2><p>单链表分为数据域和指针域，数据域用于存放当前节点所表示的数据，而指针域则用于表示指向下一个节点的地址。</p>
<p>定义方式如下，其中 typedef 是为了后续方便表示，不需要加 struct 关键字了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<p>LNode 和 LinkList 本质上是等价的都表示指针，但是在意思表达上前者表示节点，而后者表示一个链表。</p>
<h2 id="5-单链表的基本操作"><a href="#5-单链表的基本操作" class="headerlink" title="5. 单链表的基本操作"></a>5. 单链表的基本操作</h2><ul>
<li>初始化单链表时分带头节点和不带头节点两种类型，其中带头节点的单链表写代码更为方便。</li>
</ul>
<p>注意，每次创建链表需要创建一个头节点，这个头节点的数据域什么都不存，目的是为了方便创建链表。每次遍历链表都从头节点开始，所以头节点很重要，头节点没了。这个链表就找不到了，而头插法则是在头节点和剩余节点之间插入。</p>
<ul>
<li>例如起始部分只有头节点一个，那么直接插在头节点尾部即可。</li>
<li>当插入第二个元素之时依旧插在头节点之后紧邻头节点，第二个元素的指针域则指向第一个元素。</li>
<li>当插入第三个元素之时依旧插在头节点之后并且紧邻头节点，其指针域指向第第二个元素。</li>
<li>后续的依次，就这样，但是链表开始的位置以及是从头节点，所以头插法相当于将输入的数据逆序了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_H</span><span class="params">(Linklist &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Linklist s;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter the number of elements&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter every element&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> LNode;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s-&gt;data;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-尾插法"><a href="#5-1-尾插法" class="headerlink" title="5.1 尾插法"></a>5.1 尾插法</h3><p>尾插法是一直插在尾部，注意和头插法不同，注意需要新加一个指针 r （尾指针） ，参与迭代，头指针不能动，动了以后就找不到头就没了，需要将头部地址保存，要么自己不参与迭代复制一份给 r ，让 r 参与迭代，要么自己参与之前复制一份留在那。也就是头节点不能丢了，和头插法不同，头插法的头节点是一直不动的，新加进来的数据一指插在头节点之后！</p>
<ul>
<li>例如插入第一个数据的之前，先将头节点复制一份，也就是指针 r 指向头节点 L，</li>
<li>当插入第一个数据之时指针 r 的指针域指向新数据 s，之后 r 本身再指向 s，完成了一次插入。注意因为 r 的存在头指针 L 一直没有动，所以保留了下来使得这个链表没有丢失。</li>
<li>插入第二个数据之时，r 的指针域指向新数据，而 r 本身在再指向新数据，注意每一次插入新数据后 r 一直在链表的尾部，所以也称尾指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(Linklist &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Linklist s, r;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;please input the number of elements&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;please input every elements&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> LNode;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s-&gt;data;</span><br><span class="line">        s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-取值"><a href="#5-2-取值" class="headerlink" title="5.2 取值"></a>5.2 取值</h3><p>注意头指针非常重要，上面提过，丢失后就相当于整个链表都找不到了。所以不可改动最好提前备份。 思路：为了去某个位置的值，所以需要从头节点开始遍历。直到遍历到目标位置结束输出。注意遍历的过程中需要时刻判断链表遍历完全，如果遍历完了还没有到位置说明这个位置越界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElem_L</span><span class="params">(Linklist L,<span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    Linklist p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; i || p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-查找"><a href="#5-3-查找" class="headerlink" title="5.3 查找"></a>5.3 查找</h3><p>遍历一遍即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LocateElem_L</span><span class="params">(Linklist L,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    Linklist p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == e) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-插入"><a href="#5-4-插入" class="headerlink" title="5.4 插入"></a>5.4 插入</h3><p>思路：遍历到位置后插入即可，注意指针的顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L,<span class="keyword">int</span> i ,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    Linklist p = L, s;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || j &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s = <span class="keyword">new</span> LNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-删除"><a href="#5-5-删除" class="headerlink" title="5.5 删除"></a>5.5 删除</h3><p>注意顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete_L</span><span class="params">(Linklist &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    Linklist p, q;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i<span class="number">-1</span> &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; i - <span class="number">1</span>  || p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt; next = q-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-双向链表"><a href="#6-双向链表" class="headerlink" title="6. 双向链表"></a>6. 双向链表</h2><p>单链表只有两个域，数据域和指针域，而双向链表在此基础上又增加了一个指针域，但是这个指针指向的是前一个节点的地址。</p>
<p>所以双向链表不仅可以现后还可以向前操作。数据结构如下。定义时加了一个指向前驱节点的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLinklist</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLinklist</span> *<span class="title">prior</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DuLnode, *DuLinklist;</span><br></pre></td></tr></table></figure>

<h2 id="7-循环链表"><a href="#7-循环链表" class="headerlink" title="7. 循环链表"></a>7. 循环链表</h2><p>循环链表是首尾相接，最后一个节点的指针指向头节点，这样从任何一个节点出发都可以遍历全部节点。</p>
<p>因为最后一个节点的指针指向头节点，所以当单链表为空的时候，头节点的指针域指向其本身。</p>
<p>而双向链表的头指针要指向前一个节点，同样当表为空的时候双向链表的头指针指向本身。即 <code>L-&gt;next = L-&gt;prior = L</code></p>
<p>循环单链表对于需要频繁访问头节点和尾节点的操作比较友好，前提是令头指针始终指向尾节点。</p>
<p>因为如果令头指针始终指向尾节点的话，直接访问下一个节点就可以达到访问头节点的目的。</p>
<h2 id="8-循环双链表"><a href="#8-循环双链表" class="headerlink" title="8. 循环双链表"></a>8. 循环双链表</h2><p>循环双链表是在双链表的基础上构成的，双链表的尾节点的尾指针指向了头节点，而头节点的前驱指针指向了尾巴节点，最终形成了收尾相连的情况。</p>
<p>初始化的时候，因为只有一个节点，所以该节点的前驱指针和后继指针都是指向自己。因为自己即时头节点又是尾节点。</p>
<h2 id="9-静态链表"><a href="#9-静态链表" class="headerlink" title="9. 静态链表"></a>9. 静态链表</h2><p>静态链表的内存空间是连续的，而单链表在内存中散乱分布。</p>
<p>静态链表可以采用数组来实现。存在两种定义方式，本质是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;SLinkList[Maxsize];</span><br></pre></td></tr></table></figure>

<p>优点：增删操作不需要大量移动元素。</p>
<p>缺点：不能随机存取，只能从头节点开始依次往后查找，容量固定不可变！</p>
<p>可用于操作系统的 FAT 分配表。</p>
<h2 id="10-顺序表和单链表的比较"><a href="#10-顺序表和单链表的比较" class="headerlink" title="10. 顺序表和单链表的比较"></a>10. 顺序表和单链表的比较</h2><ol>
<li>逻辑结构：二者都是线性结构。</li>
<li>存储结构：顺序表支持随机存取，采用整块的内存且不要单独存储指向下一个地址的指针所以存储密度高。但是改查不方便。而链表改查方便，适用于离散的小空间，但不可随机存取，并且因为需要存储指针所以存储密度低。</li>
<li>创建，销毁，插入，删除，查找。<ol>
<li>创建：</li>
<li>销毁：如果顺序表的数组是静态数组，那么这块空间由操作系统自动回收。如果是动态数组，那么需要手动 free 。链表申请的节点也需要手动 free 。</li>
<li>插入，删除：顺序表和链表对于插入和删除操作的平均时间复杂度都是$$O(n)$$ 。但是对于前者而言时间消耗在了移动元素上，对于后者而言时间消耗在了查找元素上。实际情况中，后者耗时要少，因为和查找相比移动操作的时间开销大。</li>
<li>查找：查找分为按位查找和按值查找，对于顺序表而言按位查找显然是$$O(1)$$ ，对于单链表而言则是$$O(n)$$ 。对于单链表而言都是 $$O(n)$$。但是对于顺序表而言，如果有序可以采用二分查找等操作将时间复杂度压缩的$$O(log_2{18})$$ ，但是链表不行！</li>
</ol>
</li>
</ol>
<p>链表：表长难以估计，增加删除操作多。</p>
<p>顺序表：表厂可以估计，查询操作较多。</p>
<h1 id="第三章：栈和队列"><a href="#第三章：栈和队列" class="headerlink" title="第三章：栈和队列"></a>第三章：栈和队列</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>栈是特殊的线性表，也就是只能在一端进行插入或删除。</p>
<p>空栈：栈中没有元素。栈顶指允许删除和插入的一端，栈底则反之。</p>
<p>栈是先进后出，Last In First Out 简称 LIFO</p>
<p>队列是先进先出，First In First Out 简称 FIFO</p>
<p>题型：判断出栈顺序，出栈顺序的所有可能为卡特兰数。</p>
<p>栈可以的存储结构可以采用静态实现也就是数组或指针，也可以采用动态实现的方式也就是链栈。</p>
<p>根据栈的存储结构实现方式可以将其分为顺序栈（数组/指针），共享栈和链栈（是否带头节点）三种实现方式。</p>
<h1 id="2-顺序栈"><a href="#2-顺序栈" class="headerlink" title="2. 顺序栈"></a>2. 顺序栈</h1><ul>
<li>根据栈的特性思考栈的数据结构，采用两个指针，一个指向头部，一个指向栈底。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqStack</span> &#123;</span></span><br><span class="line">    ElemType *top; </span><br><span class="line">    ElemType *base;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以采用静态存储，用数组直接存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqStack</span> &#123;</span></span><br><span class="line">    ElemType data[Maxsize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p>静态栈的栈满后想要扩展是比较麻烦的。</p>
<h2 id="2-1-栈的基本操作"><a href="#2-1-栈的基本操作" class="headerlink" title="2.1 栈的基本操作"></a>2.1 栈的基本操作</h2><p>如果采用指针来实现，初始头部和尾部在同一个位置。<code>S.top = S.base;</code></p>
<p>如果采用数组来实现，那么 top 值需要明确一下定义。</p>
<p>根据 top 的定义来设定其值，一般而言 top 指针存在两种定义方式。</p>
<ul>
<li>一种是指向当前栈顶元素，那么 top 初始值就是 -1，因为 0 位置最初没有存元素。所以判断栈是否为空时可以直接判断 top 是否等于 -1 即可。</li>
<li>另一种是指向栈顶元素后面一个位置的元素，top 初始值为 0 。判断栈空的条件是 <code>top == 0</code></li>
</ul>
<p>入栈：要先判断栈是否满了，没有满再进栈，头部指针加一，尾指针不动，</p>
<p>出栈：出栈就反过来了，需要先判断是否到达栈底了，如果没有就出去，反之不行。</p>
<h1 id="3-共享栈"><a href="#3-共享栈" class="headerlink" title="3. 共享栈"></a>3. 共享栈</h1><p>共享栈指两个栈共享同一块内存空间，二者相向生长。对于两个栈而言自己的栈底是对方的栈顶而对方的栈顶则是自己的栈底。实际上就是为了更好的利用存储空间。</p>
<p><code>top0 == -1</code> 表示 0 号栈栈空，<code>top1 == MaxSize</code> 表示 1 号栈栈空。</p>
<p><code>top1 - top0 == 1</code> 表示栈满。</p>
<h1 id="5-链栈"><a href="#5-链栈" class="headerlink" title="5. 链栈"></a>5. 链栈</h1><p>链栈没有采用数组存储而是采用的链表的方式存储，和单链表类似。所以顺序栈的空间是连续的而链栈的空间是离散的。</p>
<h1 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h1><p>队列表示只能在一端进行插入，另一端进行删除。先进先出（FIFO）。</p>
<p>术语：队头元素指执行删除元素的一端，队尾元素指指向插入元素的一端，空队列指队列中元素为空的情况。</p>
<p>采用静态数组来存储，结构体要分别定义队头和队尾两个指针。</p>
<p>循环队列，因为删除操作导致空间出现剩余，所以队尾指针经过取余操作跳转到这块内存可空间的头部。</p>
<h2 id="4-1-空队列和满队列的判断"><a href="#4-1-空队列和满队列的判断" class="headerlink" title="4.1 空队列和满队列的判断"></a>4.1 空队列和满队列的判断</h2><p>队列已满的条件判断，存在以下三种方法。因为队满和队空的情况仅靠头指针和尾指针是无法区分的。第一种方法是浪费一块存储空间，后两种方法则是增加辅助变量。</p>
<ol>
<li>循环队列要空出一个元素用于判断队列是否为空，因为头指针和尾指针指向同一个位置表示队列为空，而队尾经过不断的插入循环回来最终也会指向队头指针，所以要空出一个元素。</li>
<li>也可以在结构体中增加一个属性 size 用于判断队列长度，所以就不用浪费一个节点了。</li>
<li>可以增加一个变量，用于判断执行的是插入操作还是删除操作。对于队满的情况，一定是插入操作所导致的，对于队列为空的情况一定是删除操作所导致的。这样就可以区分队满和对空的情况了。</li>
</ol>
<h2 id="4-2-队列元素个数计算"><a href="#4-2-队列元素个数计算" class="headerlink" title="4.2 队列元素个数计算"></a>4.2 队列元素个数计算</h2><p>队列元素个数计算：<code>(rear + Maxsize - front)%Maxsize</code> 。</p>
<h2 id="4-3-队尾指针定义"><a href="#4-3-队尾指针定义" class="headerlink" title="4.3 队尾指针定义"></a>4.3 队尾指针定义</h2><p>注意区分队尾指针的定义，定义不同代码实现也不同，一般存在以下两种定义方式：</p>
<ol>
<li>指向当前队尾元素。</li>
<li>指向队尾元素的下一个元素。</li>
</ol>
<h1 id="5-表达式求值"><a href="#5-表达式求值" class="headerlink" title="5. 表达式求值"></a>5. 表达式求值</h1><h2 id="5-1-表达式的组成"><a href="#5-1-表达式的组成" class="headerlink" title="5.1 表达式的组成"></a>5.1 表达式的组成</h2><p>表达式由操作数，运算符和界限符三部分组成。</p>
<blockquote>
<p>例如：$$((1+2)*3)$$ ，其中 1 2 3 是操作数，+ * 是操作数，( ) 是界限符。界限符保证了运算的次序。否则删除界限符运算次序就改变了 $$1+2*3$$。</p>
</blockquote>
<h2 id="5-2-后缀表达式，前缀表达式"><a href="#5-2-后缀表达式，前缀表达式" class="headerlink" title="5.2 后缀表达式，前缀表达式"></a>5.2 后缀表达式，前缀表达式</h2><p>后缀表达式由操作数和运算符两部分组成，删除了界限符，也就是左右括号。</p>
<p>但是为了保证运算次序，肯定不能单纯的删除界限符，需要存在一定的逻辑。</p>
<h2 id="5-3-中缀转后缀，中缀转前缀。"><a href="#5-3-中缀转后缀，中缀转前缀。" class="headerlink" title="5.3 中缀转后缀，中缀转前缀。"></a>5.3 中缀转后缀，中缀转前缀。</h2><p>运算符在两个操作数后面，变换逻辑如下：</p>
<blockquote>
<p>例如： a + b =&gt; a b + a + b - c =&gt; a b + c - a + b - c =&gt; a b c - + （中缀表达式转后缀表达式不唯一，左优先的原则结果唯一）</p>
</blockquote>
<p>中缀表达式：运算符在两个操作数前面。</p>
<blockquote>
<p>例如： a + b - c =&gt; - + a b c a + b - c * d =&gt; - + a b * c d</p>
</blockquote>
<p>后缀表达式也叫逆波兰式，同理前缀表达式称为波兰式。</p>
<p>因为不同的计算次序出来的结果不同，为了方便排错建议按照左优先来计算，和算法流程保持一致。</p>
<p>同理，中缀转前缀按照右优先的原则，也就是只要右边的运算符能先计算就优先算右边的。</p>
<h2 id="5-4-中缀表达式求值"><a href="#5-4-中缀表达式求值" class="headerlink" title="5.4 中缀表达式求值"></a>5.4 中缀表达式求值</h2><p>有两种方式，一种是采用一个栈来模拟，先将中缀表达式转换成后缀表达式。</p>
<p>然后后缀表达式逐渐压入栈中，遇到操作数就弹出计算，将结果压入其中，不断重复该过程。</p>
<p>除此之外可以采用两个栈来模拟，分别是运算符栈和操作数栈。</p>
<blockquote>
<p>难点：中缀表达式转后缀表达式算法。</p>
</blockquote>
<p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。</p>
<p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>
<p>遇到<strong>操作数</strong>，直接加入后缀表达式，</p>
<p>遇到<strong>界限符</strong>，遇到”(“直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。注意：“(“不加入后缀表达式，</p>
<p>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再把当前的运算符入栈。</p>
<h1 id="第四章：串"><a href="#第四章：串" class="headerlink" title="第四章：串"></a>第四章：串</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>基本概念：</p>
<ul>
<li>串：字符串，由零个或多个字符组成的有限序列。</li>
<li>串长：串中字符的个数。</li>
<li>空串：串长为零的串。</li>
<li>子串：串中任意个连续字符组成的子序列。而原串是该串的主串。</li>
</ul>
<p>空格也是也算字符。空格串则是全部由空格组成的字符串。空串是没有字符，于空格串不同。</p>
<p>在存储字符串是时候以 <code>\0</code> 结尾表示字符串的结束，但是这个字符不在字符串长度内。</p>
<p>字符串的存储方式也有<strong>顺序存储</strong>和<strong>链式存储</strong>两种。但是更多的还是采用顺序存储，索引方便。</p>
<p>一个字符的大小是 1 个字节。</p>
<h2 id="2-串的比较"><a href="#2-串的比较" class="headerlink" title="2. 串的比较"></a>2. 串的比较</h2><p>比较两个串时，当前缀出现不同的部分时，出现更大的字符则该串更大。</p>
<p>例如：</p>
<blockquote>
<p>“abandon” “aboard”<br>o &gt; a 所以 ”aboard” &gt; “abandon”</p>
</blockquote>
<p>当前缀都相同时，串更长的部分大。</p>
<blockquote>
<p>“aboard” “aboardaaa”<br>因为 “aboardaaa” 更长，所以 “aboardaaa” &gt; “aboard” 。</p>
</blockquote>
<p>两个串完全相同时串才相等。</p>
<h2 id="3-串的存储结构"><a href="#3-串的存储结构" class="headerlink" title="3. 串的存储结构"></a>3. 串的存储结构</h2><h3 id="3-1-串的顺序存储"><a href="#3-1-串的顺序存储" class="headerlink" title="3.1 串的顺序存储"></a>3.1 串的顺序存储</h3><p>存储结构可以采用数组实现。优点是可以随机存取，缺点是插入和删除麻烦。</p>
<p>数组又分为静态数组和动态数组，前者是在栈中开辟空间，也就是直接声明。而后者是在堆中开辟空间，可以采用 new、malloc 来实现。</p>
<p>串长的表示存在三种方案：</p>
<ol>
<li>在声明结构体时也声明数组 length 。</li>
<li>在 ch[0] 记录串长，因为 char 是一个字节，所以最多只能记录 255 。优点是字符和位序相同。</li>
<li>在串的结尾末尾插入 “\0” ，该字符对应的 ASC 码为 0 。缺点是需要变量才能知道长度。</li>
<li>该方案是方案一和方案二的结合，但是舍弃了 ch[0] ，这一点保证了位序从 1 开始。而长度在结构体中声明。</li>
</ol>
<h3 id="3-2-串的链式存储"><a href="#3-2-串的链式存储" class="headerlink" title="3.2 串的链式存储"></a>3.2 串的链式存储</h3><p>如果采用链表来存储，可以采用链表加数组的方式，因为单独一个 char 存的数据太少！也就是一个节点就是一个数组。</p>
<h2 id="4-模式匹配算法"><a href="#4-模式匹配算法" class="headerlink" title="4. 模式匹配算法"></a>4. 模式匹配算法</h2><p>模式匹配就是子串的定位运算，也成为串匹配。</p>
<blockquote>
<p>例如有两个串 S，T，其中 S 为主串，T 为子串，也称为模式。在主串 S 中查找与模式 T 项匹配的子串，如果查找成功就返回子串第一个字符在主串中的位置。</p>
</blockquote>
<p>比较直观的想法就是暴力，不断枚举。发现相同就继续比较，不同的话就回溯再比较，也就是 BF 算法。</p>
<h2 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h2><p>BF 即 Brute Force 也就是蛮力算法。如果不清楚可以按照下面的测试数据，拿笔画一遍就明白了。注意下标从 0 开始。</p>
<ul>
<li>abaabaabeca</li>
<li>abaabe</li>
<li>3</li>
</ul>
<p>直观的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = a.length();</span><br><span class="line">    <span class="keyword">int</span> n = b.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m-n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i+j] != b[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是另一个写法，可以看出 <code>i = i - j + 1</code> 如果不匹配就后退，说明 i 在后退，后续的 KMP 则是在这个框架的基础上使得 i 不后退。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.length() &amp;&amp; j &lt; b.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == b.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - b.length();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暴力匹配失败最坏情况为长度为 m 的主串没进一步都需要比较 n 次，最多进 m - n +1 ，所以时间复杂度是 。</p>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>BF 算法存在回溯，起始可以不需要回溯，KMP 算法就是一路走到底，不回头。下标 i 不会减少，一旦不匹配之时通过减少 j 来实现重新比对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>* p,<span class="keyword">int</span> next[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第五章：递归"><a href="#第五章：递归" class="headerlink" title="第五章：递归"></a>第五章：递归</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><strong>递归就是方法自己调用自己</strong>,每次调用时<strong>传入不同的变量</strong>.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。并且递归用到了<strong>虚拟机栈</strong></p>
<h2 id="2、能解决的问题"><a href="#2、能解决的问题" class="headerlink" title="2、能解决的问题"></a>2、能解决的问题</h2><p><strong>数学问题</strong></p>
<ul>
<li>八皇后问题</li>
<li>汉诺塔</li>
<li>求阶乘</li>
<li>迷宫问题</li>
<li>球和篮子</li>
</ul>
<p><strong>各种排序算法</strong></p>
<h2 id="3、规则"><a href="#3、规则" class="headerlink" title="3、规则"></a>3、规则</h2><ul>
<li><p>方法的变量是独立的，不会相互影响的</p>
</li>
<li><p>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据</p>
</li>
<li><p>递归<strong>必须向退出递归的条件逼近</strong>，否则就是无限递归，出现 StackOverflowError</p>
</li>
<li><p>当一个方法执行完毕，或者遇到 return，就会返回，<strong>遵守谁调用，就将结果返回给谁</strong>，同时当方法执行完毕或</p>
<p>者返回时，该方法也就执行完毕</p>
</li>
</ul>
<h2 id="4、迷宫问题"><a href="#4、迷宫问题" class="headerlink" title="4、迷宫问题"></a>4、迷宫问题</h2><p><strong>思路</strong></p>
<ul>
<li><p>用一个二维矩阵代表地图</p>
<ul>
<li>1代表边界</li>
<li>0代表未做过该地点</li>
<li>2代表走过且能走得通</li>
<li>3代表走过但走不通</li>
</ul>
</li>
<li><p>设置起点和终点以及每个地点的</p>
<p>行走策略</p>
<ul>
<li>行走策略指<strong>在该点所走的方向的顺序</strong>，如 右-&gt;下-&gt;左-&gt;上（调用寻找路径的方法，使用递归）</li>
</ul>
</li>
<li><p>每次行走时假设该点能够走通，然后按照策略去判断，如果所有策略判断后都走不通，则<strong>该点走不通</strong></p>
</li>
</ul>
<p><strong>图解</strong></p>
<p>初始地图</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618223850.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618223850.png" alt="img"></a></p>
<p><strong>行走路径</strong></p>
<p>策略：右下左上</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618224021.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618224021.png" alt="img"></a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//得到地图</span></span><br><span class="line">      <span class="keyword">int</span> length = <span class="number">7</span>;</span><br><span class="line">      <span class="keyword">int</span> width = <span class="number">6</span>;</span><br><span class="line">      <span class="keyword">int</span>[][] map = getMap(length, width);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置一些障碍</span></span><br><span class="line">      map[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">      map[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//打印地图</span></span><br><span class="line">      System.out.println(<span class="string">&quot;地图如下&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;width; j++) &#123;</span><br><span class="line">            System.out.print(map[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//走迷宫</span></span><br><span class="line">      getWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//行走路径</span></span><br><span class="line">      System.out.println(<span class="string">&quot;行走路径&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;width; j++) &#123;</span><br><span class="line">            System.out.print(map[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建地图</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length 地图的长</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> width 地图的宽</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 创建好的地图</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getMap(<span class="keyword">int</span> length, <span class="keyword">int</span> width) &#123;</span><br><span class="line">      <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[length][width];</span><br><span class="line">      <span class="comment">//先将第一行和最后一行设置为1（边界）</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;width; i++) &#123;</span><br><span class="line">         map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">         map[length-<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//再将第一列和最后一列设置为1</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">         map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">         map[i][width-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 开始走迷宫</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map 地图</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i 起点横坐标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> j 七点纵坐标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 能否走通，true能走通，false反之</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> length= map.length;</span><br><span class="line">      <span class="keyword">int</span> width = map[<span class="number">0</span>].length;</span><br><span class="line">      <span class="comment">//假设右下角为终点</span></span><br><span class="line">      <span class="keyword">if</span>(map[length-<span class="number">2</span>][width-<span class="number">2</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="comment">//走通了，返回true</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//假设改路能走通</span></span><br><span class="line">            map[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//行走策略 右-&gt;下-&gt;左-&gt;上</span></span><br><span class="line">            <span class="keyword">if</span>(getWay(map, i, j+<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getWay(map, i+<span class="number">1</span>, j)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getWay(map, i-<span class="number">1</span>, j)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getWay(map, i, j-<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右下左上都走不通</span></span><br><span class="line">            map[i][j] = <span class="number">3</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//改路已经被标记过了，不用再走了，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">地图如下</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">行走路径</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="5、八皇后问题"><a href="#5、八皇后问题" class="headerlink" title="5、八皇后问题"></a>5、八皇后问题</h2><p>八皇后问题，是一个古老而著名的问题，是<strong>回溯算法</strong>的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在 8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都<strong>不能处于同一行、同一列或同一斜线上</strong>，问有多少种摆法(92)。</p>
<p><strong>思路</strong></p>
<ul>
<li>将第一个皇后放在第一行第一列</li>
<li>将第二个皇后放在第二行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止</li>
<li>将第三个皇后放在第三行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止，并<strong>以此类推</strong>，<strong>在摆放的过程中，有可能会改动前面所放的皇后的位置</strong></li>
<li>当得到一个正确的解时，就会回溯到上一行，由此来找出第一个皇后在第一行第一列的所有解</li>
<li>再将第一个皇后放到第一行第二列，并重复以上四个步骤</li>
<li><strong>注意</strong>：<ul>
<li>棋盘本身应该是用二维数组表示，但是因为皇后所在的行数是固定的，所以可以简化为用一个一维数组来表示。其中的值代表皇后所在的列</li>
<li>数组下标代表皇后所在行数，所以判断是否在同一行列斜线上时，只需要判断是否在同一列和同一斜线上即可<ul>
<li>是否同列判断：值是否相同</li>
<li>是否同一斜线：行号-行号是否等于列号-列号，且<strong>列号相减要取绝对值</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建皇后所放位置的数组，数组的下标代表行号，数组中的值代表所在的列号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span>  max = <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Demo3 demo = <span class="keyword">new</span> Demo3();</span><br><span class="line">      <span class="comment">//放入第一个皇后，开始求后面的皇后</span></span><br><span class="line">      demo.check(<span class="number">0</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;一共有&quot;</span>+sum+<span class="string">&quot;种放法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印数组元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">         System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      sum++;</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断该位置的皇后与前面几个是否冲突</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> position 需要判断的皇后的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true代表冲突，false代表不冲突</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;position; i++) &#123;</span><br><span class="line">         <span class="comment">//如果两个皇后在同一列或者同一斜线，就冲突</span></span><br><span class="line">         <span class="comment">//因为数组下标代表行数，所以不会存在皇后在同一行</span></span><br><span class="line">         <span class="comment">//所在行数-所在行数 如果等于 所在列数-所在列数，则两个皇后在同一斜线上</span></span><br><span class="line">         <span class="keyword">if</span>(arr[i] == arr[position] || (position-i) == Math.abs(arr[position]-arr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查该皇后应放的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> queen 要检查的皇后</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> queen)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(queen == max) &#123;</span><br><span class="line">         <span class="comment">//所有的皇后都放好了，打印并返回</span></span><br><span class="line">         print();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//把皇后放在每一列上，看哪些不会和之前的冲突</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;max; i++) &#123;</span><br><span class="line">         <span class="comment">//把第queen+1个皇后放在第i列</span></span><br><span class="line">         arr[queen] = i;</span><br><span class="line">         <span class="keyword">if</span>(!judge(queen)) &#123;</span><br><span class="line">            <span class="comment">//不冲突，就去放下一个皇后</span></span><br><span class="line">            check(queen+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共有92种放法，就不一一展示了</p>
<h1 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h1>]]></content>
  </entry>
</search>
